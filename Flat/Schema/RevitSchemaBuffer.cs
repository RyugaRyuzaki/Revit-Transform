// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace Revit_Transform.Flat.Schema
{

    using global::System;
    using global::System.Collections.Generic;
    using global::Google.FlatBuffers;

    public struct RevitSchemaBuffer : IFlatbufferObject
    {
        private Table __p;
        public ByteBuffer ByteBuffer { get { return __p.bb; } }
        public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
        public static RevitSchemaBuffer GetRootAsRevitSchemaBuffer(ByteBuffer _bb) { return GetRootAsRevitSchemaBuffer(_bb, new RevitSchemaBuffer()); }
        public static RevitSchemaBuffer GetRootAsRevitSchemaBuffer(ByteBuffer _bb, RevitSchemaBuffer obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
        public static bool VerifyRevitSchemaBuffer(ByteBuffer _bb) { Google.FlatBuffers.Verifier verifier = new Google.FlatBuffers.Verifier(_bb); return verifier.VerifyBuffer("", false, RevitSchemaBufferVerify.Verify); }
        public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
        public RevitSchemaBuffer __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

        public Schema.GeometryBuffer? Geometries(int j) { int o = __p.__offset(4); return o != 0 ? (Schema.GeometryBuffer?)(new Schema.GeometryBuffer()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
        public int GeometriesLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
        public Schema.MaterialBuffer? Materials(int j) { int o = __p.__offset(6); return o != 0 ? (Schema.MaterialBuffer?)(new Schema.MaterialBuffer()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
        public int MaterialsLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }
        public Schema.ImageBuffer? Images(int j) { int o = __p.__offset(8); return o != 0 ? (Schema.ImageBuffer?)(new Schema.ImageBuffer()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
        public int ImagesLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }
        public Schema.TextureBuffer? Textures(int j) { int o = __p.__offset(10); return o != 0 ? (Schema.TextureBuffer?)(new Schema.TextureBuffer()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
        public int TexturesLength { get { int o = __p.__offset(10); return o != 0 ? __p.__vector_len(o) : 0; } }
        public Schema.ObjectItemBuffer? Objects(int j) { int o = __p.__offset(12); return o != 0 ? (Schema.ObjectItemBuffer?)(new Schema.ObjectItemBuffer()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
        public int ObjectsLength { get { int o = __p.__offset(12); return o != 0 ? __p.__vector_len(o) : 0; } }
        public string Elementtypes(int j) { int o = __p.__offset(14); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
        public int ElementtypesLength { get { int o = __p.__offset(14); return o != 0 ? __p.__vector_len(o) : 0; } }
        public string Levels(int j) { int o = __p.__offset(16); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
        public int LevelsLength { get { int o = __p.__offset(16); return o != 0 ? __p.__vector_len(o) : 0; } }
        public string Drawings(int j) { int o = __p.__offset(18); return o != 0 ? __p.__string(__p.__vector(o) + j * 4) : null; }
        public int DrawingsLength { get { int o = __p.__offset(18); return o != 0 ? __p.__vector_len(o) : 0; } }
        public string Info { get { int o = __p.__offset(20); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetInfoBytes() { return __p.__vector_as_span<byte>(20, 1); }
#else
        public ArraySegment<byte>? GetInfoBytes() { return __p.__vector_as_arraysegment(20); }
#endif
        public byte[] GetInfoArray() { return __p.__vector_as_array<byte>(20); }
        public string Drawingurl { get { int o = __p.__offset(22); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetDrawingurlBytes() { return __p.__vector_as_span<byte>(22, 1); }
#else
        public ArraySegment<byte>? GetDrawingurlBytes() { return __p.__vector_as_arraysegment(22); }
#endif
        public byte[] GetDrawingurlArray() { return __p.__vector_as_array<byte>(22); }
        public Schema.RoomBuffer? Rooms(int j) { int o = __p.__offset(24); return o != 0 ? (Schema.RoomBuffer?)(new Schema.RoomBuffer()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
        public int RoomsLength { get { int o = __p.__offset(24); return o != 0 ? __p.__vector_len(o) : 0; } }

        public static Offset<Schema.RevitSchemaBuffer> CreateRevitSchemaBuffer(FlatBufferBuilder builder,
            VectorOffset geometriesOffset = default(VectorOffset),
            VectorOffset materialsOffset = default(VectorOffset),
            VectorOffset imagesOffset = default(VectorOffset),
            VectorOffset texturesOffset = default(VectorOffset),
            VectorOffset objectsOffset = default(VectorOffset),
            VectorOffset elementtypesOffset = default(VectorOffset),
            VectorOffset levelsOffset = default(VectorOffset),
            VectorOffset drawingsOffset = default(VectorOffset),
            StringOffset infoOffset = default(StringOffset),
            StringOffset drawingurlOffset = default(StringOffset),
            VectorOffset roomsOffset = default(VectorOffset))
        {
            builder.StartTable(11);
            RevitSchemaBuffer.AddRooms(builder, roomsOffset);
            RevitSchemaBuffer.AddDrawingurl(builder, drawingurlOffset);
            RevitSchemaBuffer.AddInfo(builder, infoOffset);
            RevitSchemaBuffer.AddDrawings(builder, drawingsOffset);
            RevitSchemaBuffer.AddLevels(builder, levelsOffset);
            RevitSchemaBuffer.AddElementtypes(builder, elementtypesOffset);
            RevitSchemaBuffer.AddObjects(builder, objectsOffset);
            RevitSchemaBuffer.AddTextures(builder, texturesOffset);
            RevitSchemaBuffer.AddImages(builder, imagesOffset);
            RevitSchemaBuffer.AddMaterials(builder, materialsOffset);
            RevitSchemaBuffer.AddGeometries(builder, geometriesOffset);
            return RevitSchemaBuffer.EndRevitSchemaBuffer(builder);
        }

        public static void StartRevitSchemaBuffer(FlatBufferBuilder builder) { builder.StartTable(11); }
        public static void AddGeometries(FlatBufferBuilder builder, VectorOffset geometriesOffset) { builder.AddOffset(0, geometriesOffset.Value, 0); }
        public static VectorOffset CreateGeometriesVector(FlatBufferBuilder builder, Offset<Schema.GeometryBuffer>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
        public static VectorOffset CreateGeometriesVectorBlock(FlatBufferBuilder builder, Offset<Schema.GeometryBuffer>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
        public static VectorOffset CreateGeometriesVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Schema.GeometryBuffer>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
        public static VectorOffset CreateGeometriesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Schema.GeometryBuffer>>(dataPtr, sizeInBytes); return builder.EndVector(); }
        public static void StartGeometriesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
        public static void AddMaterials(FlatBufferBuilder builder, VectorOffset materialsOffset) { builder.AddOffset(1, materialsOffset.Value, 0); }
        public static VectorOffset CreateMaterialsVector(FlatBufferBuilder builder, Offset<Schema.MaterialBuffer>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
        public static VectorOffset CreateMaterialsVectorBlock(FlatBufferBuilder builder, Offset<Schema.MaterialBuffer>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
        public static VectorOffset CreateMaterialsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Schema.MaterialBuffer>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
        public static VectorOffset CreateMaterialsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Schema.MaterialBuffer>>(dataPtr, sizeInBytes); return builder.EndVector(); }
        public static void StartMaterialsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
        public static void AddImages(FlatBufferBuilder builder, VectorOffset imagesOffset) { builder.AddOffset(2, imagesOffset.Value, 0); }
        public static VectorOffset CreateImagesVector(FlatBufferBuilder builder, Offset<Schema.ImageBuffer>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
        public static VectorOffset CreateImagesVectorBlock(FlatBufferBuilder builder, Offset<Schema.ImageBuffer>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
        public static VectorOffset CreateImagesVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Schema.ImageBuffer>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
        public static VectorOffset CreateImagesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Schema.ImageBuffer>>(dataPtr, sizeInBytes); return builder.EndVector(); }
        public static void StartImagesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
        public static void AddTextures(FlatBufferBuilder builder, VectorOffset texturesOffset) { builder.AddOffset(3, texturesOffset.Value, 0); }
        public static VectorOffset CreateTexturesVector(FlatBufferBuilder builder, Offset<Schema.TextureBuffer>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
        public static VectorOffset CreateTexturesVectorBlock(FlatBufferBuilder builder, Offset<Schema.TextureBuffer>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
        public static VectorOffset CreateTexturesVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Schema.TextureBuffer>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
        public static VectorOffset CreateTexturesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Schema.TextureBuffer>>(dataPtr, sizeInBytes); return builder.EndVector(); }
        public static void StartTexturesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
        public static void AddObjects(FlatBufferBuilder builder, VectorOffset objectsOffset) { builder.AddOffset(4, objectsOffset.Value, 0); }
        public static VectorOffset CreateObjectsVector(FlatBufferBuilder builder, Offset<Schema.ObjectItemBuffer>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
        public static VectorOffset CreateObjectsVectorBlock(FlatBufferBuilder builder, Offset<Schema.ObjectItemBuffer>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
        public static VectorOffset CreateObjectsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Schema.ObjectItemBuffer>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
        public static VectorOffset CreateObjectsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Schema.ObjectItemBuffer>>(dataPtr, sizeInBytes); return builder.EndVector(); }
        public static void StartObjectsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
        public static void AddElementtypes(FlatBufferBuilder builder, VectorOffset elementtypesOffset) { builder.AddOffset(5, elementtypesOffset.Value, 0); }
        public static VectorOffset CreateElementtypesVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
        public static VectorOffset CreateElementtypesVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
        public static VectorOffset CreateElementtypesVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
        public static VectorOffset CreateElementtypesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
        public static void StartElementtypesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
        public static void AddLevels(FlatBufferBuilder builder, VectorOffset levelsOffset) { builder.AddOffset(6, levelsOffset.Value, 0); }
        public static VectorOffset CreateLevelsVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
        public static VectorOffset CreateLevelsVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
        public static VectorOffset CreateLevelsVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
        public static VectorOffset CreateLevelsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
        public static void StartLevelsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
        public static void AddDrawings(FlatBufferBuilder builder, VectorOffset drawingsOffset) { builder.AddOffset(7, drawingsOffset.Value, 0); }
        public static VectorOffset CreateDrawingsVector(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
        public static VectorOffset CreateDrawingsVectorBlock(FlatBufferBuilder builder, StringOffset[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
        public static VectorOffset CreateDrawingsVectorBlock(FlatBufferBuilder builder, ArraySegment<StringOffset> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
        public static VectorOffset CreateDrawingsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<StringOffset>(dataPtr, sizeInBytes); return builder.EndVector(); }
        public static void StartDrawingsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
        public static void AddInfo(FlatBufferBuilder builder, StringOffset infoOffset) { builder.AddOffset(8, infoOffset.Value, 0); }
        public static void AddDrawingurl(FlatBufferBuilder builder, StringOffset drawingurlOffset) { builder.AddOffset(9, drawingurlOffset.Value, 0); }
        public static void AddRooms(FlatBufferBuilder builder, VectorOffset roomsOffset) { builder.AddOffset(10, roomsOffset.Value, 0); }
        public static VectorOffset CreateRoomsVector(FlatBufferBuilder builder, Offset<Schema.RoomBuffer>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
        public static VectorOffset CreateRoomsVectorBlock(FlatBufferBuilder builder, Offset<Schema.RoomBuffer>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
        public static VectorOffset CreateRoomsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Schema.RoomBuffer>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
        public static VectorOffset CreateRoomsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Schema.RoomBuffer>>(dataPtr, sizeInBytes); return builder.EndVector(); }
        public static void StartRoomsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
        public static Offset<Schema.RevitSchemaBuffer> EndRevitSchemaBuffer(FlatBufferBuilder builder)
        {
            int o = builder.EndTable();
            return new Offset<Schema.RevitSchemaBuffer>(o);
        }
        public static void FinishRevitSchemaBufferBuffer(FlatBufferBuilder builder, Offset<Schema.RevitSchemaBuffer> offset) { builder.Finish(offset.Value); }
        public static void FinishSizePrefixedRevitSchemaBufferBuffer(FlatBufferBuilder builder, Offset<Schema.RevitSchemaBuffer> offset) { builder.FinishSizePrefixed(offset.Value); }
    }


    static public class RevitSchemaBufferVerify
    {
        static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
        {
            return verifier.VerifyTableStart(tablePos)
              && verifier.VerifyVectorOfTables(tablePos, 4 /*Geometries*/, Schema.GeometryBufferVerify.Verify, false)
              && verifier.VerifyVectorOfTables(tablePos, 6 /*Materials*/, Schema.MaterialBufferVerify.Verify, false)
              && verifier.VerifyVectorOfTables(tablePos, 8 /*Images*/, Schema.ImageBufferVerify.Verify, false)
              && verifier.VerifyVectorOfTables(tablePos, 10 /*Textures*/, Schema.TextureBufferVerify.Verify, false)
              && verifier.VerifyVectorOfTables(tablePos, 12 /*Objects*/, Schema.ObjectItemBufferVerify.Verify, false)
              && verifier.VerifyVectorOfStrings(tablePos, 14 /*Elementtypes*/, false)
              && verifier.VerifyVectorOfStrings(tablePos, 16 /*Levels*/, false)
              && verifier.VerifyVectorOfStrings(tablePos, 18 /*Drawings*/, false)
              && verifier.VerifyString(tablePos, 20 /*Info*/, false)
              && verifier.VerifyString(tablePos, 22 /*Drawingurl*/, false)
              && verifier.VerifyVectorOfTables(tablePos, 24 /*Rooms*/, Schema.RoomBufferVerify.Verify, false)
              && verifier.VerifyTableEnd(tablePos);
        }
    }

}
